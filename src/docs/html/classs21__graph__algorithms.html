<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple Navigator: s21_graph_algorithms Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Simple Navigator<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Simple Navigator</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classs21__graph__algorithms.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classs21__graph__algorithms-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">s21_graph_algorithms Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class containing algorithms for graph processing.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="graph__algorithms_8h_source.html">graph_algorithms.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7c2be937af098cf2e5bbb8f731b65524" id="r_a7c2be937af098cf2e5bbb8f731b65524"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c2be937af098cf2e5bbb8f731b65524">DepthFirstSearch</a> (<a class="el" href="classs21__graph.html">s21_graph</a> &amp;graph, int start_vertex)</td></tr>
<tr class="memdesc:a7c2be937af098cf2e5bbb8f731b65524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a Depth First Search on the graph.  <br /></td></tr>
<tr class="separator:a7c2be937af098cf2e5bbb8f731b65524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b30b5ce853d48943ae02f44b94214cb" id="r_a7b30b5ce853d48943ae02f44b94214cb"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b30b5ce853d48943ae02f44b94214cb">BreadthFirstSearch</a> (<a class="el" href="classs21__graph.html">s21_graph</a> &amp;graph, int start_vertex)</td></tr>
<tr class="memdesc:a7b30b5ce853d48943ae02f44b94214cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a Breadth First Search on the graph.  <br /></td></tr>
<tr class="separator:a7b30b5ce853d48943ae02f44b94214cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d81c8c40ce8b5b6791fa4a3a2d23af" id="r_af6d81c8c40ce8b5b6791fa4a3a2d23af"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; int, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6d81c8c40ce8b5b6791fa4a3a2d23af">GetShortestPathBetweenVertices</a> (<a class="el" href="classs21__graph.html">s21_graph</a> &amp;graph, int vertex1, int vertex2)</td></tr>
<tr class="memdesc:af6d81c8c40ce8b5b6791fa4a3a2d23af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the shortest path between two vertices using Dijkstra's algorithm.  <br /></td></tr>
<tr class="separator:af6d81c8c40ce8b5b6791fa4a3a2d23af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c28cdacd34babba29830ed414f7890b" id="r_a9c28cdacd34babba29830ed414f7890b"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c28cdacd34babba29830ed414f7890b">GetShortestPathsBetweenAllVertices</a> (<a class="el" href="classs21__graph.html">s21_graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a9c28cdacd34babba29830ed414f7890b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the shortest paths between all pairs of vertices using Floyd-Warshall algorithm.  <br /></td></tr>
<tr class="separator:a9c28cdacd34babba29830ed414f7890b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13020ec984f3143bce514d6faf3935f2" id="r_a13020ec984f3143bce514d6faf3935f2"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; int, std::vector&lt; std::vector&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13020ec984f3143bce514d6faf3935f2">GetLeastSpanningTree</a> (<a class="el" href="classs21__graph.html">s21_graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a13020ec984f3143bce514d6faf3935f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the Least Spanning Tree of the graph using Prim's algorithm.  <br /></td></tr>
<tr class="separator:a13020ec984f3143bce514d6faf3935f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750a2b5aafb837439395bc32e439550c" id="r_a750a2b5aafb837439395bc32e439550c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_tsm_result.html">TsmResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a750a2b5aafb837439395bc32e439550c">SolveTravelingSalesmanProblem</a> (<a class="el" href="classs21__graph.html">s21_graph</a> &amp;graph, <a class="el" href="graph__algorithms_8h.html#aa0c42b7cf53e91d84080c741c8bb343e">TSPAlgorithm</a> algorithm=<a class="el" href="graph__algorithms_8h.html#aa0c42b7cf53e91d84080c741c8bb343ea65756f87700529eeed641ce1af7cc709">TSPAlgorithm::ACO</a>)</td></tr>
<tr class="memdesc:a750a2b5aafb837439395bc32e439550c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Traveling Salesman Problem for the given graph.  <br /></td></tr>
<tr class="separator:a750a2b5aafb837439395bc32e439550c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a1c33056840c4b0dadbb2c17405f77c57" id="r_a1c33056840c4b0dadbb2c17405f77c57"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c33056840c4b0dadbb2c17405f77c57">CheckVertex</a> (<a class="el" href="classs21__graph.html">s21_graph</a> &amp;graph, int vertex)</td></tr>
<tr class="memdesc:a1c33056840c4b0dadbb2c17405f77c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a vertex index is valid for the given graph.  <br /></td></tr>
<tr class="separator:a1c33056840c4b0dadbb2c17405f77c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a7c6355e80c562664bfdaf8bd6dceaa97" id="r_a7c6355e80c562664bfdaf8bd6dceaa97"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c6355e80c562664bfdaf8bd6dceaa97">kIntMax</a> = std::numeric_limits&lt;int&gt;::max()</td></tr>
<tr class="memdesc:a7c6355e80c562664bfdaf8bd6dceaa97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents positive infinity for integer distances.  <br /></td></tr>
<tr class="separator:a7c6355e80c562664bfdaf8bd6dceaa97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class containing algorithms for graph processing. </p>
<p>This class provides static methods for various graph algorithms such as Depth First Search, Breadth First Search, shortest path calculations, finding the least spanning tree, and solving the Traveling Salesman Problem. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7b30b5ce853d48943ae02f44b94214cb" name="a7b30b5ce853d48943ae02f44b94214cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b30b5ce853d48943ae02f44b94214cb">&#9670;&#160;</a></span>BreadthFirstSearch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; s21_graph_algorithms::BreadthFirstSearch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classs21__graph.html">s21_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_vertex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a Breadth First Search on the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to search. </td></tr>
    <tr><td class="paramname">start_vertex</td><td>The vertex to start the search from (1-indexed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of visited vertices in BFS order. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if start_vertex is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c33056840c4b0dadbb2c17405f77c57" name="a1c33056840c4b0dadbb2c17405f77c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c33056840c4b0dadbb2c17405f77c57">&#9670;&#160;</a></span>CheckVertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool s21_graph_algorithms::CheckVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classs21__graph.html">s21_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vertex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a vertex index is valid for the given graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph. </td></tr>
    <tr><td class="paramname">vertex</td><td>The vertex index (1-indexed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the vertex is valid, false otherwise. </dd></dl>

</div>
</div>
<a id="a7c2be937af098cf2e5bbb8f731b65524" name="a7c2be937af098cf2e5bbb8f731b65524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2be937af098cf2e5bbb8f731b65524">&#9670;&#160;</a></span>DepthFirstSearch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; s21_graph_algorithms::DepthFirstSearch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classs21__graph.html">s21_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_vertex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a Depth First Search on the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to search. </td></tr>
    <tr><td class="paramname">start_vertex</td><td>The vertex to start the search from (1-indexed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of visited vertices in DFS order. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if start_vertex is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13020ec984f3143bce514d6faf3935f2" name="a13020ec984f3143bce514d6faf3935f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13020ec984f3143bce514d6faf3935f2">&#9670;&#160;</a></span>GetLeastSpanningTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, std::vector&lt; std::vector&lt; int &gt; &gt; &gt; s21_graph_algorithms::GetLeastSpanningTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classs21__graph.html">s21_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the Least Spanning Tree of the graph using Prim's algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to process. Must be weighted and undirected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing the total weight of the MST and the adjacency matrix of the MST. Returns {-1, {}} if the graph is not suitable (e.g., disconnected and unable to form a single tree, or not weighted undirected). </dd></dl>

</div>
</div>
<a id="af6d81c8c40ce8b5b6791fa4a3a2d23af" name="af6d81c8c40ce8b5b6791fa4a3a2d23af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d81c8c40ce8b5b6791fa4a3a2d23af">&#9670;&#160;</a></span>GetShortestPathBetweenVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, std::vector&lt; int &gt; &gt; s21_graph_algorithms::GetShortestPathBetweenVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classs21__graph.html">s21_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vertex1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vertex2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the shortest path between two vertices using Dijkstra's algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to search. </td></tr>
    <tr><td class="paramname">vertex1</td><td>The starting vertex (1-indexed). </td></tr>
    <tr><td class="paramname">vertex2</td><td>The ending vertex (1-indexed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing the shortest distance and the path (vector of vertices). If no path exists, distance is infinity and path is empty. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if vertex1 or vertex2 is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c28cdacd34babba29830ed414f7890b" name="a9c28cdacd34babba29830ed414f7890b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c28cdacd34babba29830ed414f7890b">&#9670;&#160;</a></span>GetShortestPathsBetweenAllVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; int &gt; &gt; s21_graph_algorithms::GetShortestPathsBetweenAllVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classs21__graph.html">s21_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the shortest paths between all pairs of vertices using Floyd-Warshall algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix where element (i, j) is the shortest distance from vertex i to vertex j. std::numeric_limits&lt;int&gt;::max() indicates no path. </dd></dl>

</div>
</div>
<a id="a750a2b5aafb837439395bc32e439550c" name="a750a2b5aafb837439395bc32e439550c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750a2b5aafb837439395bc32e439550c">&#9670;&#160;</a></span>SolveTravelingSalesmanProblem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_tsm_result.html">TsmResult</a> s21_graph_algorithms::SolveTravelingSalesmanProblem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classs21__graph.html">s21_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="graph__algorithms_8h.html#aa0c42b7cf53e91d84080c741c8bb343e">TSPAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algorithm</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="graph__algorithms_8h.html#aa0c42b7cf53e91d84080c741c8bb343ea65756f87700529eeed641ce1af7cc709">TSPAlgorithm::ACO</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves the Traveling Salesman Problem for the given graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to solve TSP for. Must be a complete weighted graph. </td></tr>
    <tr><td class="paramname">algorithm</td><td>The algorithm to use (ACO, Nearest Neighbor, Brute Force). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_tsm_result.html" title="Structure to store the result of the Traveling Salesman Problem.">TsmResult</a> struct containing the best route found and its distance. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the graph is not suitable for TSP (e.g., not complete, or has 0 vertices). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7c6355e80c562664bfdaf8bd6dceaa97" name="a7c6355e80c562664bfdaf8bd6dceaa97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6355e80c562664bfdaf8bd6dceaa97">&#9670;&#160;</a></span>kIntMax</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int s21_graph_algorithms::kIntMax = std::numeric_limits&lt;int&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents positive infinity for integer distances. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>graph_algorithms/<a class="el" href="graph__algorithms_8h_source.html">graph_algorithms.h</a></li>
<li>graph_algorithms/<a class="el" href="graph__algorithms_8cc.html">graph_algorithms.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classs21__graph__algorithms.html">s21_graph_algorithms</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
